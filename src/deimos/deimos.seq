/* -*- C -*- */
/** ---------------------------------------------------------------------------
 * @file     deimos.seq
 * @brief    sequence file for DEIMOS science detectors
 * @author   Joseph Bichel
 * @date     2024-12-02
 * @modified 
 *
 */

/** ---------------------------------------------------------------------------

/** ---------------------------------------------------------------------------
 * parameter definitions
 * syntax: param paramname=value
*/



/** System Control Triggers **/
param readout_enable = 1 //will be pulled externally when we want a frame
param integrate_enable = 0 // to be set externally if we want an integration time

param integrate_ms = 0 // will be set externally to choose integration ms
param integrate_s = 0 // will be set externally to choose integration seconds

param framecount = 0 //will be set 
param abortintegrate = 0 //checked by the integration waiters and they bail out if it is set


SEQUENCE StartSeq {
    if integrate_enable CheckIntegrate();
    if readout_enable CheckReadout();
    framecount--;
    GOTO StartSeq();
}

SEQUENCE CheckIntegrate
{
  if framecount Integrate();
  RETURN;
}
  
SEQUENCE Integrate
{
  SetupIntegration();
  Wait1ms(integrate_ms);
  Wait1s(integrate_s);
  TearDownIntegration();
  RETURN;
}

SEQUENCE CheckReadout
{
  if framecount KeepThisFrame();
  FrameReadout();
  RETURN;
}


#define LINE_COLS #eval _SERIALPRESCAN + _AMPCOLS


//segment calculations
//this does floor arithmetic, so might end up with wrong number
//if number cols changes
#define PIXELS_PER_SEG #eval _AMPCOLS / 3
#define REMAINDER_PIX #eval _AMPCOLS - (PIXELS_PER_SEG * 3)


SEQUENCE FrameReadout
{
  ReadoutBegin();
  //single serial read to flush the register
  ReadPixels(_AMPREADCOLS);
  //read all image rows
  LineReadout(_IMAGEROWS);
  //and the desired overscan
  LineReadout(_PARALLELOVERSCAN);
  RETURN;
}


//NOTE this has to be a sequence because can't call
//enough repeats in 1ms archon limit of repeats
SEQUENCE Wait1s {
  if abortintegrate abortintegration();
  Wait1ms(1000);
  RETURN;
}

SEQUENCE abortintegration {
  TearDownIntegration();
  GOTO StartSeq();
}


SEQUENCE LineReadout
{
  TransferToSerialRegister();
  ReadPixels(_SERIALPRESCAN);
  ParallelForwardSegment1();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSegment2();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSegment3();
  ReadPixels(PIXELS_PER_SEG);
  //if there are leftover pixels, do them here
  #if _AMPCOLS % 3
   ReadPixels(REMAINDER_PIX);

  #endif
   RETURN;
}

SEQUENCE LineReadoutAOnly
{
  TransferToSerialRegister();
  ReadPixels(_SERIALPRESCAN);
  ParallelForwardSectionASegment1();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSectionASegment2();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSectionASegment3();
  ReadPixels(PIXELS_PER_SEG);

  #if _AMPCOLS %3
      ReadPixels(REMAINDER_PIX);
  #endif
      RETURN ;
}

SEQUENCE ParallelDCMeasReadout
{
  ReadoutBegin();
  //single line read to flush the register
  ReadPixels(_AMPREADCOLS);
    
  //dump the 'A' image section
  LineReadoutAOnly(_SECTION_A_ROWS);
  ParallelDCLineLoop(LLEL_TDC_LOOPS);
  RETURN;

}

SEQUENCE ParallelDCLineLoop
{
  //now we have a bunch of charge in B section, A section is empty
  //go forward on B clocks only, this gets a bright line into section A
  //multiple forwards of section B bins charge into section A
  ForwardParallelSectionB(LLEL_TDC_BINS);

  //then forward for the number of line spacings
  LineReadoutAOnly(LLEL_TDC_LINE_SPACING);
  RETURN;
}

  
SEQUENCE SerialDCMeasReadoutE
{
  ReadoutBegin();
  //single line read to flush the register
  ReadPixels(_AMPREADCOLS);

  //run the serial DC line loop
  
  RETURN;
}

SEQUENCE SerialDCLineLoopE
{
  //first we dump a number of lines into the serial register (to build up the charge size)
  ForwardParallelAll(SER_TDC_LLEL_BINS);

  //now empty the E side of the register
  ReadPixelsEOnly(_AMPCOLS);

  //read out pixels from E only - the number read out is the spacing
  ReadPixelsEOnly(SER_TDC_ROW_SPACING);
  

  RETURN;
  
}

SEQUENCE SerialDCRowLoopE
{
  //back clock F the defined number of times this should get a bright line into E
  SerialFBackwards(SER_TDC_SER_BINS);
  //read out the pixels from E register only - NO NEED TO 
  ReadPixelsEOnly(SER_TDC_ROW_SPACING);

  RETURN;
}
