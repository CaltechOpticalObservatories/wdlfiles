/* -*- C -*- */
/** ---------------------------------------------------------------------------
 * @file     deimos.seq
 * @brief    sequence file for DEIMOS science detectors
 * @author   Joseph Bichel
 * @date     2024-12-02
 * @modified 
 *
 */

/** ---------------------------------------------------------------------------

/** ---------------------------------------------------------------------------
 * parameter definitions
 * syntax: param paramname=value
*/



/** System Control Triggers **/
param readout_enable = 0 //will be pulled externally when we want a frame
param integrate_enable = 0 // to be set externally if we want an integration time

param integrate_ms = 50 // will be set externally to choose integration ms
param integrate_s = 0 // will be set externally to choose integration seconds

param framecount = 1000 //will be set 
param abortintegrate = 0 //checked by the integration waiters and they bail out if it is set

param flush = 1


  param llel_coincident = 1 //use coincident llel clocks
  param llel_seq = 0 //use sequential llel clocks (must be not of llel_coincident)  

#if NOISETEST
SEQUENCE NoiseTest {
  setupTGTest();
  BounceTGTestOuter(_IMAGEROWS);
  BounceTGTestOuter(_PARALLELOVERSCAN);
  GOTO NoiseTest();
}

  

SEQUENCE BounceTGTestOuter
{
  TGTestLineStart();
  BounceTGTest(_AMPREADCOLS);
  RETURN;
}

#endif

#if CLAMPTEST

#define CLAMP_TEST_ITERS  #eval  _AMPREADCOLS / 4

SEQUENCE ClampTestRun {
  //note clamp test and TG setup are the same
  setupTGTest();

  ClampTestOuter(_IMAGEROWS);
  ClampTestOuter(_PARALLELOVERSCAN);
  GOTO ClampTestRun;
}


SEQUENCE ClampTestOuter
{
  ClampTestLineStart();
  ClampTest(CLAMP_TEST_ITERS);
  RETURN;

}


SEQUENCE ClampTest
{
  ClampOn();
  ClampTestInner(2);
  ClampOff();
  ClampTestInner(2);
  RETURN;
}

#endif

#if 0
SEQUENCE TestBrokenReadout
{
  OutputTestSetup();
  PulseTGA();

  VRDModulate();

  GOTO TestBrokenReadout();
}
#endif



SEQUENCE StartSeq {
  InitialSetup();
  if flush Flush(); 
  
    if integrate_enable CheckIntegrate();
    if readout_enable CheckReadout();
    framecount--;
    GOTO StartSeq();
}

SEQUENCE Flush
{
  FlushSetup();
  Wait1s();
  FlushTearDown();
  Wait1ms(10);
  RETURN Flush;
}



SEQUENCE CheckIntegrate
{
  if framecount Integrate();
  RETURN;
}
  
SEQUENCE Integrate
{
  SetupIntegration();
  Wait1ms(integrate_ms);
  Wait1s(integrate_s);
  TearDownIntegration();
  RETURN;
}

SEQUENCE CheckReadout
{
  if framecount KeepThisFrame();
  FrameReadout();
  RETURN;
}




//segment calculations
//this does floor arithmetic, so might end up with wrong number
//if number cols changes
#define PIXELS_PER_SEG #eval _AMPREADCOLS  / 3
#define REMAINDER_PIX #eval _AMPREADCOLS - (PIXELS_PER_SEG * 3)


#define  TOTAL_ROWS #eval _IMAGEROWS + _PARALLELOVERSCAN

SEQUENCE FrameReadout
{

  //Readout begin does half a llel transfer, so wait while that settles doewn
  ReadoutBegin();
  Wait1us(50);
  //single serial read to flush the register
  ReadPixels(_AMPREADCOLS);

 
  
  //read all image rows and the desired overscan
  IF llel_seq LineReadout(TOTAL_ROWS);
  IF llel_coincident  LineReadoutCoincident(TOTAL_ROWS);

  ReadoutEnd();
  RETURN;
}


//NOTE this has to be a sequence because can't call
//enough repeats in 1ms archon limit of repeats
SEQUENCE Wait1s {
  if abortintegrate abortintegration();
  Wait1ms(1000);
  RETURN;}

SEQUENCE abortintegration {
  TearDownIntegration();
  GOTO StartSeq();
}


SEQUENCE LineReadout
{ 
  ParallelForwardNoCoincident();

  //wait here is for the clamp to die down. Put some of it in prescan, but not all
  Wait1us(50);

  ReadPixels(PIXELS_PER_SEG);
  ReadPixels(PIXELS_PER_SEG);
  ReadPixels(PIXELS_PER_SEG);
  //if there are leftover pixels, do them here
  #if REMAINDER_PIX
   ReadPixels(REMAINDER_PIX);

  #endif

   Wait1us(10);
   RETURN;
}

SEQUENCE LineReadoutCoincident
{
  //charge assumed must be under I2 at this point, set up in preamble
  ParallelForwardSegment1();
  TransferToSerialRegisterCoincident();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSegment2();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSegment3();
  ReadPixels(PIXELS_PER_SEG)
    #if REMAINDER_PIX
    ReadPixels(REMAINDER_PIX);
  #endif

  RETURN;
}


SEQUENCE LineReadoutAOnly
{
  TransferToSerialRegisterCoincident();
  ReadPixels(_SERIALPRESCAN);
  ParallelForwardSectionASegment1();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSectionASegment2();
  ReadPixels(PIXELS_PER_SEG);
  ParallelForwardSectionASegment3();
  ReadPixels(PIXELS_PER_SEG);

  #if REMAINDER_PIX
      ReadPixels(REMAINDER_PIX);
  #endif
      RETURN ;
}

SEQUENCE ParallelDCMeasReadout
{
  ReadoutBegin();
  //single line read to flush the register
  ReadPixels(_AMPREADCOLS);
    
  //dump the 'A' image section
  LineReadoutAOnly(_SECTION_A_ROWS);
  ParallelDCLineLoop(LLEL_TDC_LOOPS);
  RETURN;

}

SEQUENCE ParallelDCLineLoop
{
  //now we have a bunch of charge in B section, A section is empty
  //go forward on B clocks only, this gets a bright line into section A
  //multiple forwards of section B bins charge into section A
  ForwardParallelSectionB(LLEL_TDC_BINS);

  //then forward for the number of line spacings
  LineReadoutAOnly(LLEL_TDC_LINE_SPACING);
  RETURN;
}

  
SEQUENCE SerialDCMeasReadoutE
{
  ReadoutBegin();
  //single line read to flush the register
  ReadPixels(_AMPREADCOLS);

  //run the serial DC line loop
  
  RETURN;
}

SEQUENCE SerialDCLineLoopE
{
  //first we dump a number of lines into the serial register (to build uBp the charge size)
  ForwardParallelAll(SER_TDC_LLEL_BINS);

  //now empty the E side of the register
  ReadPixelsEOnly(_AMPCOLS);

  //read out pixels from E only - the number read out is the spacing
  ReadPixelsEOnly(SER_TDC_ROW_SPACING);
  

  RETURN;
  
}

SEQUENCE SerialDCRowLoopE
{
  //back clock F the defined number of times this should get a bright line into E
  SerialFBackwards(SER_TDC_SER_BINS);
  //read out the pixels from E register only - NO NEED TO 
  ReadPixelsEOnly(SER_TDC_ROW_SPACING);

  RETURN;
}
